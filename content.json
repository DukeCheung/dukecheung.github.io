{"meta":{"title":"Duke","subtitle":"学海无涯","description":null,"author":"ZhangXing","url":"http://chaunceyzhangx.github.io"},"pages":[{"title":"About","date":"2018-03-28T04:52:15.591Z","updated":"2018-03-28T04:52:15.591Z","comments":true,"path":"about/index.html","permalink":"http://chaunceyzhangx.github.io/about/index.html","excerpt":"","text":"Email: dukestar@qq.com"},{"title":"Tags","date":"2018-03-27T13:35:28.302Z","updated":"2018-03-27T13:35:28.302Z","comments":true,"path":"tags/index.html","permalink":"http://chaunceyzhangx.github.io/tags/index.html","excerpt":"","text":""},{"title":"Categories","date":"2018-03-27T11:41:53.033Z","updated":"2018-03-11T05:45:56.000Z","comments":true,"path":"categories/index.html","permalink":"http://chaunceyzhangx.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Unity 3D 巡逻兵","slug":"Unity-3D-巡逻兵","date":"2018-05-11T12:00:00.000Z","updated":"2018-05-11T14:20:24.412Z","comments":true,"path":"2018/05/11/Unity-3D-巡逻兵/","link":"","permalink":"http://chaunceyzhangx.github.io/2018/05/11/Unity-3D-巡逻兵/","excerpt":"要求： 创建一个地图和若干巡逻兵(使用动画)； 每个巡逻兵走一个3~5个边的凸多边型，位置数据是相对地址。即每次确定下一个目标位置，用自己当前位置为原点计算；","text":"要求： 创建一个地图和若干巡逻兵(使用动画)； 每个巡逻兵走一个3~5个边的凸多边型，位置数据是相对地址。即每次确定下一个目标位置，用自己当前位置为原点计算； 巡逻兵碰撞到障碍物，则会自动选下一个点为目标； 巡逻兵在设定范围内感知到玩家，会自动追击玩家； 失去玩家目标后，继续巡逻； 计分：玩家每次甩掉一个巡逻兵计一分，与巡逻兵碰撞游戏结束； 说明： 新建一个空对象，将 FirstSceneController.cs , PatrolFactory.cs , UI.cs 挂载到该对象上即可运行。 使用WSAD或者方向键控制方向，WS控制前进后退，AD控制向左右转向。空格键加速。 若WSAD无法正常工作，切换键盘为大写英文或者使用方向键控制即可。 游戏里共有三类对象，分别为玩家，巡逻兵，和地板。玩家我是在Asset Store里找的资源，巡逻兵为老师给的Garen，地板即是简单Cube与Plane的组合，其实还贴了墙纸，只不过摄像机看不清纹路。 效果图： 实现： Action 接口，声明玩家的动作： 123456public interface Action&#123; void move(float x, float z);//移动玩家 void gameOver();//游戏结束 void changeScore();//加分&#125; ​ Director 导演类，使用单例模式实现： 12345678910111213141516171819202122232425262728293031323334public class Director : System.Object&#123; private static Director _instance; private bool isEnd = false;//标志游戏是否结束 public SceneController currentSceneController &#123; get; set; &#125; public static Director getInstance() &#123; if (_instance == null) &#123; _instance = new Director(); &#125; return _instance; &#125; public bool getState() &#123; return _instance.isEnd; &#125; public void end() &#123; _instance.isEnd = true; &#125; public void reset()//重新开始游戏 &#123; _instance.isEnd = false; &#125; public int getFPS() &#123; return Application.targetFrameRate; &#125; public void setFPS(int fps) &#123; Application.targetFrameRate = fps; &#125;&#125; ScoreRecorder 记分员，同样采用单例模式： 1234567891011121314151617181920212223242526public class ScoreRecorder:System.Object//记分员&#123; private int score = 0; private static ScoreRecorder instance; public static ScoreRecorder getInstance() &#123; if(instance == null) &#123; instance = new ScoreRecorder(); &#125; return instance; &#125; public void record()//加分 &#123; instance.score++; &#125; public int getScore() &#123; return instance.score; &#125; public void reset() &#123; instance.score = 0; &#125;&#125; PatrolFactory 工厂模式，由于此次不牵扯回收问题，所以只用写创造巡逻兵即可： 12345678910111213141516171819202122232425262728293031323334public class PatrolFactory : MonoBehaviour &#123; List&lt;GameObject&gt; list = new List&lt;GameObject&gt;(); public List&lt;GameObject&gt; getPatrolmans() &#123; int[] x = new int[2] &#123; -10, 5 &#125;; int[] z = new int[3] &#123; -5, 0, 5 &#125;; Vector3[] location = new Vector3[9]; int count = 0; for(int i = 0;i &lt; 2; i++) &#123; for(int j = 0;j &lt; 3; j++) &#123; GameObject patrolman = Instantiate(Resources.Load(&quot;Prefabs/Patrolman&quot;), new Vector3(0, 0, 7), Quaternion.identity) as GameObject; location[count] = new Vector3(x[i], 0, z[j]); patrolman.transform.position = location[count]; patrolman.GetComponent&lt;Animator&gt;().SetBool(&quot;run&quot;, true);//默认巡逻兵为移动 list.Add(patrolman); count++; &#125; &#125; return list; &#125; public void removeRigid()//结束后调用，移除刚体，以免对象之间继续碰撞 &#123; for(int i = 0;i &lt; list.Count; i++) &#123; list[i].GetComponent&lt;Animator&gt;().SetBool(&quot;run&quot;, false); list[i].GetComponent&lt;Animator&gt;().SetBool(&quot;idle&quot;, true); Destroy(list[i].GetComponent&lt;Rigidbody&gt;()); &#125; &#125;&#125; PatrolmanController 负责控制巡逻兵的逻辑部分，需将其绑定到巡逻兵预制上。 我认为本次作业的难点有一大半出在此处，关键在于如何实现碰撞和如何处理碰撞。 关于实现碰撞： 首先，给巡逻兵，墙体和玩家添加刚体，并且不使用重力，给墙体选中 is Kinematic 属性，使其不会移动。这是碰撞产生的先决条件。 其次，给巡逻兵，墙体和玩家添加碰撞器，设置好大小，尤其是玩家和巡逻兵，使用 Capsule Collider 直径以刚好包住对象为宜。 最后，给巡逻兵添加触发器，即添加 Box Collider ，半径可设置稍微大一点，选中 isTrigger ，这样就可以啦。 以下是关于碰撞及触发逻辑的处理，需要注意的是，若巡逻兵在追逐玩家的过程中，玩家跑到了墙后面，或者说玩家与巡逻兵之间仅一墙之隔，巡逻兵也需优先处理碰撞到墙的情况，即碰墙或巡逻兵的优先级高于碰玩家。 这样处理的好处是不会出现隔山打牛的情况，或者巡逻兵穿墙而入，并且代码量不多。 最后，当巡逻兵追逐玩家时，速度会加快，远离之后速度恢复正常。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697void OnCollisionEnter(Collision collision)//碰撞&#123; if(collision.gameObject.tag == &quot;patrolman&quot;) &#123; canFollow = false;//添加变量，当与其他巡逻兵或者墙体碰撞时，优先处理 direction = (direction + 1) % 4; setNewPath(); &#125; else if(collision.gameObject.tag == &quot;wall&quot;) &#123; canFollow = false; direction = (direction + 1) % 4; setNewPath(); &#125; if (collision.gameObject.tag == &quot;player&quot; &amp;&amp; !dir.getState()&amp;&amp;canFollow) &#123; if (hit != null) &#123; this.GetComponent&lt;Animator&gt;().SetBool(&quot;attack&quot;, true); dir.end(); hit(); &#125; &#125;&#125;void OnCollisionExit(Collision collision)//退出碰撞&#123; if(collision.gameObject.tag == &quot;patrolman&quot;|| collision.gameObject.tag == &quot;wall&quot;) &#123; canFollow = true; &#125;&#125;void OnTriggerEnter(Collider other)//进入触发器范围&#123; if(other.transform.tag == &quot;player&quot; &amp;&amp; !dir.getState() &amp;&amp; canFollow) &#123; target = other.transform.position; this.transform.LookAt(other.transform.position); speed *= 2; &#125;&#125;void OnTriggerExit(Collider other)//退出触发器范围&#123; if (other.transform.tag == &quot;player&quot; &amp;&amp; !dir.getState() &amp;&amp; canFollow) &#123; if (scoreRecord != null) &#123; scoreRecord(); &#125; setNewPath(); speed /= 2; &#125;&#125;void setNewPath()&#123; System.Random ran = new System.Random(); length = ran.Next(5, 6); x = this.transform.position.x; z = this.transform.position.z; if (direction == 0) &#123; x -= length; &#125; else if (direction == 1) &#123; z += length; &#125; else if (direction == 2) &#123; x += length; &#125; else if (direction == 3) &#123; z -= length; &#125; if(x &lt; -15)//若超出地图，则设置边缘 &#123; x = -14; &#125; if(x &gt; 15) &#123; x = 14; &#125; if(z &lt; -15) &#123; z = -14; &#125; if(z &gt; 15) &#123; z = 14; &#125; target = new Vector3(x, 0, z); this.transform.LookAt(target);&#125; FirstSceneController 场景控制器，继承 Action 和 SceneController 接口，实现相应函数。 本次游戏的另一个重点，订阅与发布模式也在此实现。 FirstSceneController 订阅了 PatrolmanController 发布的事件，并且做出相应的动作. 12345678910void Enable()//订阅事件&#123; PatrolmanController.hit += gameOver; PatrolmanController.scoreRecord += changeScore;&#125;void Disable()//取消订阅&#123; PatrolmanController.hit -= gameOver; PatrolmanController.scoreRecord -= changeScore;;&#125; 实现接口： 123456789101112131415161718192021222324252627282930313233343536public void LoadResources()&#123; director = Director.getInstance(); director.currentSceneController = this;&#125;public void move(float x, float z) &#123; if (!director.getState()) &#123; player.GetComponent&lt;Animator&gt;().SetBool(&quot;run&quot;, true); player.transform.Translate(0, 0, z * Time.deltaTime); player.transform.Rotate(0, x * rotate_speed * 3 * Time.deltaTime, 0); if (player.transform.position.y != 0)//确保y为0 &#123; player.transform.position = new Vector3(player.transform.position.x, 0, player.transform.position.z); &#125; if (player.transform.localEulerAngles.x != 0 || player.transform.localEulerAngles.z != 0)//确保只能左右旋转 &#123; player.transform.localEulerAngles = new Vector3(0, player.transform.localEulerAngles.y, 0); &#125; &#125;&#125;public void gameOver() &#123; director.end(); player.GetComponent&lt;Animator&gt;().SetBool(&quot;run&quot;, false); player.GetComponent&lt;Animator&gt;().SetBool(&quot;idle&quot;, true); Destroy(player.GetComponent&lt;Rigidbody&gt;()); factory.removeRigid(); Disable();&#125;public void changeScore()&#123; score.record();&#125; UI 实现了基本的计时器，计分和重新开始选项。 由于巡逻兵追逐速度加快，并且触发器的范围并不是很大，所以容易造成玩家基本不可能逃出巡逻兵的魔爪。所以我设置了按下 Space 键加速的功能，方便逃出追捕范围，容易得分，可以多次在死亡的边缘试探。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263void Update()&#123; action = Director.getInstance().currentSceneController as Action; float offsetX = Input.GetAxis(&quot;Horizontal&quot;); float offsetZ = Input.GetAxis(&quot;Vertical&quot;); action.move(offsetX * rate, offsetZ * rate); if (Input.GetKeyDown(KeyCode.Space)) &#123; rate *= 3; &#125; if (Input.GetKeyUp(KeyCode.Space)) &#123; rate = 3; &#125; if (flag == 1) &#123; timer += Time.deltaTime; if (timer &gt;= 1f) &#123; second++; timer = 0; &#125; if (second &gt;= 60) &#123; minute++; second = 0; &#125; if (minute &gt;= 60) &#123; minute = 0; &#125; &#125;&#125;void OnGUI()&#123; str = string.Format(&quot;&#123;0:00&#125;:&#123;1:00&#125;&quot;, minute, second);//计时器 str = &quot;Time: &quot; + str; GUIStyle style = new GUIStyle(); style.fontSize = 20; GUI.Label(new Rect(520, 0, 100, 200), str, style); int score = s.getScore();//记分 string ss = &quot;Score: &quot; + score.ToString(); GUI.Label(new Rect(0, 0, 100, 200), ss, style); if (director.getState() == true) &#123; flag = 0; if (GUI.Button(new Rect(280, 130, 100, 50), &quot;RESET&quot;)) &#123; flag = 1; timer = 0; minute = 0; second = 0; director.reset(); s.reset(); SceneManager.LoadScene(&quot;Scene&quot;); &#125; &#125; &#125; 总结：本次作业还是有些难的，不过收获也颇多，除了订阅与发布模式，动画系统、碰撞器、触发器等部件的特性也有了很多了解。上课跟着老师做，跟自己独立完成还是有很大区别的，还是要勤动手啊。 就是过程有点痛苦。 查看代码点这里 ，附上演示视频。","categories":[{"name":"3D Game","slug":"3D-Game","permalink":"http://chaunceyzhangx.github.io/categories/3D-Game/"}],"tags":[{"name":"博客","slug":"博客","permalink":"http://chaunceyzhangx.github.io/tags/博客/"}]},{"title":"Unity 3D 鼠标打飞碟之改进版","slug":"Unity-3D-鼠标打飞碟之改进版","date":"2018-04-24T12:17:00.000Z","updated":"2018-04-24T13:59:17.658Z","comments":true,"path":"2018/04/24/Unity-3D-鼠标打飞碟之改进版/","link":"","permalink":"http://chaunceyzhangx.github.io/2018/04/24/Unity-3D-鼠标打飞碟之改进版/","excerpt":"效果图：","text":"效果图： 场景也可加天空盒等组件进行优化，选择很多。 要求： 按 adapter模式 设计图修改飞碟游戏 使它同时支持物理运动与运动学（变换）运动 思路： &emsp; 新建一个 IActionManager 类来管理动作，CCActionManager 和 PhysisActionManager 负责具体的运动学和物理引擎实现动作。其余 DiskFactory , DiskData 稍作修改即可。 实现： Action 接口，声明基类的动作： 123456public interface IAction&#123; void play(); void randomAction(int num, int level); void remove(DiskData disk);&#125; IActionManager 基类，实现接口动作，有两个类的对象和一个模式选择变量，当用户选择不同的模式时，实现不同的动作，以 play() 为例： 123456789101112131415161718192021222324CCActionManager cc;PhysisActionManager ph;int mode;public IActionManager()&#123; cc = new CCActionManager(); ph = new PhysisActionManager(); mode = 0;&#125;public void setMode(int i)&#123; mode = i;&#125;public void play()&#123; if (mode == 0) &#123; cc.play(); &#125; else &#123; ph.play(); &#125;&#125; CCAction 运动学类，通过坐标变化来实现运动，包含一个单例类的 DiskFactory ，用来回收和生产飞碟： 12345678910List&lt;DiskData&gt; diskList;DiskFactory diskFactory;float gravity = 9.8f;Color color;public CCActionManager()&#123; diskList = new List&lt;DiskData&gt;(); diskFactory = DiskFactory.getInstance();&#125; 其次，在 randomAction() 类中，通过不同的 level 来区分不同的难度，主要体现在速度不同： 12345678910111213141516public void randomAction(int ufoNum, int level)&#123; setColor(level); for (int i = 0; i &lt; ufoNum; i++) &#123; Vector3 position = new Vector3(0, 0, 0);//飞碟的起始位置 float speed = level * 10f;//飞碟速度 Vector3 direction = new Vector3( UnityEngine.Random.Range(-10f, 10f), UnityEngine.Random.Range(40f, 80f), UnityEngine.Random.Range(50f, 100f));//飞碟方向 direction.Normalize();//单位化该方向向量，以免产生较大误差 Ruler ruler = new Ruler(color, position, speed, direction);//新建一个规则 diskList.Add(diskFactory.getDisk(ruler));//添加飞碟 &#125;&#125; 再者，在 FirstSceneCtroller 类中每一帧会调用 play() 函数，以此实现飞碟的运动和回收： 1234567891011121314public void play()&#123; for (int i = 0; i &lt; diskList.Count; i++) &#123; move(diskList[i]);//移动飞碟 &#125; for (int i = 0; i &lt; diskList.Count; i++) &#123; if (diskList[i].gameObject.transform.position.y &lt; 0)//若飞碟低于地面，则回收 &#123; remove(diskList[i]); &#125; &#125;&#125; PhysisActionManager 此类负责实现物理引擎实现UFO运动，基本思路与运动学较为相似，区别是需要给UFO加一个外力，让其自己运动而不是人为的坐标变换。 我选择的方法是给UFO添加 ConstantForce 组件，一个恒力，以此实现运动效果，当物体被回收时，去掉这个恒力，具体实现代码在 DiskData 类中，如下： 123456789public void setForce(Vector3 f)&#123; this.gameObject.AddComponent&lt;ConstantForce&gt;().force = f;&#125;public void removeForce()&#123; Destroy(this.gameObject.GetComponent&lt;ConstantForce&gt;()); Destroy(this.gameObject.GetComponent&lt;Rigidbody&gt;());&#125; randomAction() 如下： 123456789101112131415public void randomAction(int ufoNum, int level)&#123; setColor(level); for (int i = 0; i &lt; ufoNum; i++) &#123; Vector3 position = new Vector3(0, 0, -20f); float speed = level * 10f;//飞碟速度 Vector3 force = new Vector3( UnityEngine.Random.Range(-5f, 5f), UnityEngine.Random.Range(10f, 12f), speed); Ruler ruler = new Ruler(color, position, 0, Vector3.zero);//新建一个规则 diskList.Add(diskFactory.getDisk(force,ruler));//添加飞碟 &#125;&#125; 此外，在 play() 函数中，就不需设置 move 函数了，只需回收飞碟即可。 FirstSceneCtroller 场景控制器，负责整个场景的调度，其中加入 IActionManager 的对象，实现物体运动： 12345678910111213141516171819Director director;IActionManager ac;ScoreRecorder score;float interval = 0;//发射飞镖的间隔时间int level = 0;//难度级别public int ufoNum = 1;//每一次发射飞碟的数目void Awake()&#123; director = Director.getInstance();//单例类 director.currentSceneCtroller = this; score = ScoreRecorder.getInstance(); LoadResource();&#125;public void LoadResource()&#123; ac = new IActionManager();&#125; 注意这里除了导演类的实例外，还有个记分员的实例，其实现与导演类相似，负责场景中的计分，实现十分简单，详见代码，在此不多加赘述。 在场景中，每一帧都会调用一次物体的运动函数，实现刷新效果： 1234567891011121314151617181920212223void Update()&#123; interval += Time.deltaTime; if (interval &gt;= 1f &amp;&amp; director.state == State.PLAYING &amp;&amp; level &gt; 0)//若间隔大于1s且处于play且已设置好level &#123; ac.randomAction(ufoNum, level); interval = 0;//间隔重新置为0 &#125; ac.play(); if (Input.GetButtonDown(&quot;Fire1&quot;))//开火 &#123; Vector3 mousePosition = Input.mousePosition; Camera cam = Camera.main; Ray ray = cam.ScreenPointToRay(mousePosition); RaycastHit hit; if (Physics.Raycast(ray, out hit)) &#123; score.record(level);//计分 recycle(hit.transform.gameObject.GetComponent&lt;DiskData&gt;());//回收 &#125; &#125;&#125; DiskFactory 该类负责UFO的制作与回收，即工厂类，主要有两个list，分别存已用过的飞碟和回收的： 1234public DiskData diskPrefab;//飞碟预制public static DiskFactory _instance;List&lt;DiskData&gt; used;//已用过的List&lt;DiskData&gt; free;//未用 负责生产飞碟的函数共有两个版本，分别是对于 CCActionManager 和 PhysisActionManager 类的，差别不大，主要区别在是否添加恒力，以下以运动学的为例： 12345678910111213141516public DiskData getDisk(Ruler ruler)//根据参数设置飞碟&#123; DiskData disk; if (_instance.free.Count &gt; 0)//若不空，则从中找 &#123; disk = _instance.free[0]; _instance.free.RemoveAt(0); &#125; else &#123; disk = Instantiate(diskPrefab); &#125; disk.ruler = ruler; _instance.used.Add(disk); return disk;&#125; 回收飞碟类： 12345678public void freeDisk(DiskData disk)//回收飞碟&#123; _instance.free.Add(disk); if (!_instance.used.Remove(disk))//抛出错误 &#123; throw new System.Exception(); &#125;&#125; DiskData 飞碟类，包含一个 Ruler 类，包含飞碟的种种规则，也可不封装成类，皆可。 123456789101112131415161718192021222324252627Ruler _ruler;public float x = 0, y = 0, z = 0;//用于存储该飞碟在飞行方向上的速度public Ruler ruler&#123; get &#123; return _ruler; &#125; set &#123; _ruler = value; x = value.speed * value.direction.x; y = value.speed * value.direction.y; z = value.speed * value.direction.z; gameObject.GetComponent&lt;Renderer&gt;().material.color = value.color; gameObject.transform.position = value.position; &#125;&#125;public void setForce(Vector3 f)&#123; this.gameObject.AddComponent&lt;ConstantForce&gt;().force = f;&#125;public void removeForce()&#123; Destroy(this.gameObject.GetComponent&lt;ConstantForce&gt;()); Destroy(this.gameObject.GetComponent&lt;Rigidbody&gt;());&#125; 需要注意的是，在使用该类时，需将其绑定到制作好的预制上，然后删除对象，即可正常使用。此时，代码中的 gameObject 就指的是脚本文件绑定的对象，即预制。 将 UI.cs ， DiskFactory.cs ， FirstSceneController.cs 拖到空对象上，拖入预制，即可运行，可自主设置每次出现的飞碟数。 还有 BaseCode.cs ， UI.cs 等文件就不加赘述了，详情可见Github 源码 。 如果有任何不懂的话，可参考第一版 鼠标打飞碟 和 演示视频 。","categories":[{"name":"3D Game","slug":"3D-Game","permalink":"http://chaunceyzhangx.github.io/categories/3D-Game/"}],"tags":[{"name":"博客","slug":"博客","permalink":"http://chaunceyzhangx.github.io/tags/博客/"}]},{"title":"MIPS汇编语言实现冒泡排序","slug":"MIPS冒泡排序","date":"2018-04-11T04:38:00.000Z","updated":"2018-04-11T05:17:21.599Z","comments":true,"path":"2018/04/11/MIPS冒泡排序/","link":"","permalink":"http://chaunceyzhangx.github.io/2018/04/11/MIPS冒泡排序/","excerpt":"题目要求：键盘输入10个无序无符号整数，实现降序输出。","text":"题目要求：键盘输入10个无序无符号整数，实现降序输出。 思路： &emsp; &emsp; 首先，写出对应的C++代码，实现排序功能，为方便MIPS指令运行，我将冒泡排序做了一点改进：每次二重循环下标都从0开始，这样就无需记录当前数组移动的下标位置，方便许多。 &emsp; &emsp; 其次，MIPS设计的重点我认为在循环的跳转上，如何递增变量，如何跳转到相应的循环需要仔细设计。我将数组的重置，j = 0放在第一重循环中，然后进行判断i&lt;10，若真，则进入第二重循环，二重循环中检测到j == 9时进入相应的模块将i++，再跳转到第一重循环中，如此即可实现排序所需的两重循环的切换。 &emsp; &emsp; 最后输出前需将对应的计数器i归零，循环输出结果和间隔符，就可以得到结果。 程序流程图： 运行结果： MIPS：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778.data.align 2 array: .space 40 # 10 integers seperate: .asciiz &quot; &quot; inputMessage: .asciiz &quot;Please enter 10 numbers:\\n&quot;.text.globl mainmain: la $a0, inputMessage li $v0, 4 syscall la $t0, array addi $t1, $zero, 0 # i addi $t2, $zero, 0 # j add $t5, $t0, $zero # head of pointers addi $t6, $zero, 10 # constant addi $t7, $zero, 9addi $t1, $zero, 0inputNumber: li $v0, 5 syscall sw $v0, 0($t0) addi $t0, $t0, 4 # array++ addi $t1, $t1, 1 # i++ blt $t1, $t6, inputNumber # i&lt;10 addi $t1, $zero, 0 # i = 0firstLoop: la $t5, array # t5 = array[0] addi $t2, $zero, 0 # j = 0 blt $t1, $t6, secondLoop # i &lt; 10, secondLoop beq $t1, $t6, init # i == 10, init secondLoop: beq $t2, $t7, nextLoop # j == 9, nextLoop lw $t3, 0($t5) lw $t4, 4($t5) blt $t3, $t4, swap addi $t5, $t5, 4 addi $t2, $t2, 1 # j++ j secondLoopnextLoop: addi $t1, $t1, 1 # i++ j firstLoopswap: sw $t3, 4($t5) sw $t4, 0($t5) addi $t5, $t5, 4 addi $t2, $t2, 1 # j++ j secondLoopinit: la $t0, array # t0 = array[0] addi $t1, $zero, 0 # i = 0printResult: lw $a0, 0($t0) li $v0, 1 syscall la $a0, seperate li $v0, 4 syscall addi $t0, $t0, 4 addi $t1, $t1, 1 blt $t1, $t6, printResultli $v0, 10syscall C++：123456789101112131415161718192021222324#include &lt;iostream&gt;using namespace std;int main()&#123; int arr[10] = &#123;0&#125;; int i = 0, j = 0, k = 0, temp = 0; for(i = 0;i &lt; 10;i++)&#123; cin &gt;&gt; arr[i]; &#125; for(i = 0;i &lt; 10;i++)&#123; for(j = 0;j &lt; 9;j++)&#123; if(arr[j] &lt; arr[j+1])&#123; temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; &#125; &#125; &#125; for(int t = 0;t &lt; 10;t++)&#123; cout &lt;&lt; arr[t] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; return 0;&#125; 补充说明：若要实现自己定义输入的数字数，则只需在 .main 下添加一句： 123li $v0, 5syscallsw $v0, 0($t6) 同时， t7 的值也要改为： 1addi $t7 $t6 -1 array 的size也要足够大。 同理，若要实现 升序 ，只需将 secondLoop 中的第四句改为： 1blt $t4 $t3 swap 即可实现效果啦。","categories":[{"name":"汇编语言","slug":"汇编语言","permalink":"http://chaunceyzhangx.github.io/categories/汇编语言/"}],"tags":[{"name":"博客","slug":"博客","permalink":"http://chaunceyzhangx.github.io/tags/博客/"}]},{"title":"Unity 3D 牧师与魔鬼场景改进版","slug":"Unity 3D牧师与魔鬼场景改进版","date":"2018-04-10T14:17:00.000Z","updated":"2018-04-11T05:22:31.238Z","comments":true,"path":"2018/04/10/Unity 3D牧师与魔鬼场景改进版/","link":"","permalink":"http://chaunceyzhangx.github.io/2018/04/10/Unity 3D牧师与魔鬼场景改进版/","excerpt":"场景改进效果图：","text":"场景改进效果图： Skybox ： 天空盒，即天空场景，添加后可看到不同的天空场景。 首先，在Unity的 Assets Store 中搜索 Skybox ，下载资源，主要为六张图片。之后新建Material，Inspector—-&gt;Shader—-&gt;Skybox，拖入六张图片，即制作好了一个材料。 下一步为摄像机添加组件，Add Component—-&gt;Rendering—-&gt;Skybox，拖入上一部创建好的图片就OK啦。 摄像机 ： 打开Camera的Inspector视图，可看到Projection属性： 有两个选项：Perspective(透视视图) ，和 Orthographic(正交视图) 。正交视图与摄像机距离无关，实现2D投影效果，透视试图则是属于3D效果。 设置两个摄像机，一个为主，采用透视视图，另一为辅，为正交视图。 需注意的重点是，若要使辅助摄像机位于视图左下角，则需调整 Depth 和视图大小，确保辅助摄像机的深度大于主摄像机。 _地形_ ： Create—-&gt;3D Object—-&gt;Terrain，即可创建地形对象： 可用来改造地形，种树，花草等等，不过若要种树，则需从 Assets Store 中下载相关资源，从中找到树木的预制，即可应用于地形中。 _海水_ ： Assets—-&gt;Import Package—-&gt;Environment，即可从该资源包中找到 Water 预制，拖入场景中，调整位置即可实现海水效果。 牧师与魔鬼详见代码","categories":[{"name":"3D Game","slug":"3D-Game","permalink":"http://chaunceyzhangx.github.io/categories/3D-Game/"}],"tags":[{"name":"博客","slug":"博客","permalink":"http://chaunceyzhangx.github.io/tags/博客/"}]},{"title":"Unity 3D 基础概念","slug":"Unity 3D之Homework1","date":"2018-03-27T11:54:00.000Z","updated":"2018-04-11T03:59:00.127Z","comments":true,"path":"2018/03/27/Unity 3D之Homework1/","link":"","permalink":"http://chaunceyzhangx.github.io/2018/03/27/Unity 3D之Homework1/","excerpt":"基础概念 GameObjects: 游戏对象，即游戏中的最基本单位，游戏中的每一个对象都是游戏对象。它相当于一个容器，本身并无太多属性，需添加各种组件，资源后才能达到设计者的所希望的游戏行为目的。","text":"基础概念 GameObjects: 游戏对象，即游戏中的最基本单位，游戏中的每一个对象都是游戏对象。它相当于一个容器，本身并无太多属性，需添加各种组件，资源后才能达到设计者的所希望的游戏行为目的。 Assets: 指可应用于Unity上的各种资源，为游戏添加各种属性，从而实现目标效果；同时，一个Unity Project的Assets文件夹指存储于本地计算机中的各种图片，预制，script等文件的总和。一个Assets中可以包含多个GameObject，GameObject从逻辑上讲存储于Assets文件夹中。 游戏结构目录：Assets Scene 保存游戏场景 Game 保存美术资源 Materials 保存材质球，用于调整颜色等 Prefabs 保存预制，即游戏对象的模板，方便克隆 Model _模型_ Animations 保存动画文件 Audio 音频文件 Textures 贴图文件 UI UI文件 Scripts 脚本文件 Plugins _插件_ Editor 保存编辑器类文件 MonoBehaviour 基本行为触发条件：代码如下： 1234567891011121314151617181920212223242526272829303132// Use this for initializationvoid Start () &#123; Debug.Log(&quot;init Start&quot;);&#125;// Update is called once per framevoid Update () &#123; Debug.Log(&quot;init Update&quot;);&#125;void Awake()&#123; Debug.Log(&quot;init Awake&quot;);&#125;void FixedUpdate()&#123; Debug.Log(&quot;init FixedUpdate&quot;);&#125;void LateUpdate()&#123; Debug.Log(&quot;init LateUpdate&quot;);&#125;void OnGUI()&#123; Debug.Log(&quot;init OnGUI&quot;);&#125;void OnDisable()&#123; Debug.Log(&quot;init OnDisable&quot;);&#125;void OnEnable()&#123; Debug.Log(&quot;init OnEnable&quot;);&#125; Start: Per frame: End: 结论: Awake(): 当脚本实例被载入时调用； Start(): 在Update()前被调用一次； Update(): 行为启用时，每一帧被调用一次； FixedUpdate(): 行为启用时，每一时间片被调用； LateUpdate(): 行为启用时，Update()之后被调用； OnGUI(): 每帧调用多次，响应GUI事件； OnEnable(): 当对象变为启用并激活时，调用该函数； OnDisable(): 当对象变为禁用或不活动时，调用该函数。 简单介绍GameObject, Transform 和 Component，并画出三者的UML图。 GameObject: Unity 场景中所有实体的基类。 Transform: 一个对象的位置，旋转和大小。 Component: 所有附加到游戏对象的属性的基类。 UML 简单代码 查找对象新建项目，其中有 Sphere 游戏对象，代码如下： 1234567891011121314151617void Start() &#123; Debug.Log(&quot;init start&quot;); &#125; void FixedUpdate() &#123; var x = GameObject.Find(&quot;Sphere&quot;); if (x.name != null) &#123; Debug.Log(&quot;find the gameobject&quot;); &#125; else &#123; Debug.Log(&quot;Not found&quot;); &#125; &#125; 添加子对象代码如下： 1234567void Start()&#123; GameObject sph = GameObject.Find(&quot;Sphere&quot;); GameObject child = GameObject.CreatePrimitive(PrimitiveType.Cube); child.transform.parent = sph.transform; Debug.Log(&quot;Success&quot;);&#125; 遍历对象树代码如下： 123456789GameObject obj = GameObject.Find(&quot;Sphere&quot;);print(&quot;父对象名称为:&quot; + obj.name + &quot; 有&quot; + obj.transform.childCount + &quot;个子对象&quot;);int i = 0;while (i &lt; obj.transform.childCount)&#123; Transform child = obj.transform.GetChild(i); print(&quot;这是第: &quot; + i + &quot; 个子对象, 名称为: &quot; + child.name); i++;&#125; 清除所有子对象代码如下： 1234567891011GameObject obj = GameObject.Find(&quot;Sphere&quot;);print(&quot;父对象名称为:&quot; + obj.name + &quot; 有&quot; + obj.transform.childCount + &quot;个子对象&quot;);int i = 0;while (i &lt; obj.transform.childCount)&#123; Transform child = obj.transform.GetChild(i); print(&quot;这是第: &quot; + i+1 + &quot; 个子对象, 名称为: &quot; + child.name); GameObject pchild = GameObject.Find(child.name); GameObject.Destroy(pchild); i++;&#125; 预设与对象克隆 Prefabs: 预制可以存储一个带有组件和属性的 GameObject 作为模板，当想创建新的实例时，可以直接拖动模板进行创建。对预制做的修改可以应用到由该模板生成的所有实例中，也可以单独编辑每一个实例。 总的来说，预设和对象克隆都能生成新的对象实例，但相比较而言，由 clone 生成的实例，编辑原对象时，就不能应用到所有实例中。 预制 table : 12345public GameObject prefab;void Start()&#123; Instantiate(prefab, new Vector3(2.0F, 0, 0), Quaternion.identity);&#125; 组合模式 组合模式: 定义：组合模式，将对象组合成树形结构以表示“部分-整体”的层次结构。组合模式使得用户对组合对象和单个对象的使用具有一致性。 包含三个部分：抽象构件，叶子构件和容器构件。 目的即是使得对根节点的调用方法对叶子节点同样适用，使得工作效率更高。 代码：​ 有三种发送消息的函数，其中BroadcastMessage()由父类发送给子类，括号里面：第一个参数为回应的函数，第二个参数为传递给回应函数的参数。 1234567void Start () &#123; gameObject.BroadcastMessage(&quot;MySon&quot;,&quot;I am your father&quot;);&#125;void MySon(string ss)&#123; Debug.Log(&quot;I am your son&quot;);&#125;","categories":[{"name":"3D Game","slug":"3D-Game","permalink":"http://chaunceyzhangx.github.io/categories/3D-Game/"}],"tags":[{"name":"博客","slug":"博客","permalink":"http://chaunceyzhangx.github.io/tags/博客/"}]}]}