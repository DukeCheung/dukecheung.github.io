{"meta":{"title":"Duke","subtitle":"学海无涯","description":null,"author":"ZhangXing","url":"http://chaunceyzhangx.github.io"},"pages":[{"title":"Categories","date":"2018-03-27T11:41:53.033Z","updated":"2018-03-11T05:45:56.000Z","comments":true,"path":"categories/index.html","permalink":"http://chaunceyzhangx.github.io/categories/index.html","excerpt":"","text":""},{"title":"About","date":"2018-03-28T04:52:15.591Z","updated":"2018-03-28T04:52:15.591Z","comments":true,"path":"about/index.html","permalink":"http://chaunceyzhangx.github.io/about/index.html","excerpt":"","text":"Email: dukestar@qq.com"},{"title":"Tags","date":"2018-03-27T13:35:28.302Z","updated":"2018-03-27T13:35:28.302Z","comments":true,"path":"tags/index.html","permalink":"http://chaunceyzhangx.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"MIPS汇编语言实现冒泡排序","slug":"MIPS冒泡排序","date":"2018-04-11T04:38:00.000Z","updated":"2018-04-11T05:17:21.599Z","comments":true,"path":"2018/04/11/MIPS冒泡排序/","link":"","permalink":"http://chaunceyzhangx.github.io/2018/04/11/MIPS冒泡排序/","excerpt":"题目要求：键盘输入10个无序无符号整数，实现降序输出。","text":"题目要求：键盘输入10个无序无符号整数，实现降序输出。 思路： &emsp; &emsp; 首先，写出对应的C++代码，实现排序功能，为方便MIPS指令运行，我将冒泡排序做了一点改进：每次二重循环下标都从0开始，这样就无需记录当前数组移动的下标位置，方便许多。 &emsp; &emsp; 其次，MIPS设计的重点我认为在循环的跳转上，如何递增变量，如何跳转到相应的循环需要仔细设计。我将数组的重置，j = 0放在第一重循环中，然后进行判断i&lt;10，若真，则进入第二重循环，二重循环中检测到j == 9时进入相应的模块将i++，再跳转到第一重循环中，如此即可实现排序所需的两重循环的切换。 &emsp; &emsp; 最后输出前需将对应的计数器i归零，循环输出结果和间隔符，就可以得到结果。 程序流程图： 运行结果： MIPS：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778.data.align 2 array: .space 40 # 10 integers seperate: .asciiz &quot; &quot; inputMessage: .asciiz &quot;Please enter 10 numbers:\\n&quot;.text.globl mainmain: la $a0, inputMessage li $v0, 4 syscall la $t0, array addi $t1, $zero, 0 # i addi $t2, $zero, 0 # j add $t5, $t0, $zero # head of pointers addi $t6, $zero, 10 # constant addi $t7, $zero, 9addi $t1, $zero, 0inputNumber: li $v0, 5 syscall sw $v0, 0($t0) addi $t0, $t0, 4 # array++ addi $t1, $t1, 1 # i++ blt $t1, $t6, inputNumber # i&lt;10 addi $t1, $zero, 0 # i = 0firstLoop: la $t5, array # t5 = array[0] addi $t2, $zero, 0 # j = 0 blt $t1, $t6, secondLoop # i &lt; 10, secondLoop beq $t1, $t6, init # i == 10, init secondLoop: beq $t2, $t7, nextLoop # j == 9, nextLoop lw $t3, 0($t5) lw $t4, 4($t5) blt $t3, $t4, swap addi $t5, $t5, 4 addi $t2, $t2, 1 # j++ j secondLoopnextLoop: addi $t1, $t1, 1 # i++ j firstLoopswap: sw $t3, 4($t5) sw $t4, 0($t5) addi $t5, $t5, 4 addi $t2, $t2, 1 # j++ j secondLoopinit: la $t0, array # t0 = array[0] addi $t1, $zero, 0 # i = 0printResult: lw $a0, 0($t0) li $v0, 1 syscall la $a0, seperate li $v0, 4 syscall addi $t0, $t0, 4 addi $t1, $t1, 1 blt $t1, $t6, printResultli $v0, 10syscall C++：123456789101112131415161718192021222324#include &lt;iostream&gt;using namespace std;int main()&#123; int arr[10] = &#123;0&#125;; int i = 0, j = 0, k = 0, temp = 0; for(i = 0;i &lt; 10;i++)&#123; cin &gt;&gt; arr[i]; &#125; for(i = 0;i &lt; 10;i++)&#123; for(j = 0;j &lt; 9;j++)&#123; if(arr[j] &lt; arr[j+1])&#123; temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; &#125; &#125; &#125; for(int t = 0;t &lt; 10;t++)&#123; cout &lt;&lt; arr[t] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; return 0;&#125; 补充说明：若要实现自己定义输入的数字数，则只需在 .main 下添加一句： 123li $v0, 5syscallsw $v0, 0($t6) 同时， t7 的值也要改为： 1addi $t7 $t6 -1 array 的size也要足够大。 同理，若要实现 升序 ，只需将 secondLoop 中的第四句改为： 1blt $t4 $t3 swap 即可实现效果啦。","categories":[{"name":"汇编语言","slug":"汇编语言","permalink":"http://chaunceyzhangx.github.io/categories/汇编语言/"}],"tags":[{"name":"博客","slug":"博客","permalink":"http://chaunceyzhangx.github.io/tags/博客/"}]},{"title":"Unity 3D 牧师与魔鬼场景改进版","slug":"Unity 3D牧师与魔鬼场景改进版","date":"2018-04-10T14:17:00.000Z","updated":"2018-04-10T15:58:20.071Z","comments":true,"path":"2018/04/10/Unity 3D牧师与魔鬼场景改进版/","link":"","permalink":"http://chaunceyzhangx.github.io/2018/04/10/Unity 3D牧师与魔鬼场景改进版/","excerpt":"场景改进效果图： Skybox ： 天空盒，即天空场景，添加后可看到不同的天空场景。","text":"场景改进效果图： Skybox ： 天空盒，即天空场景，添加后可看到不同的天空场景。 首先，在Unity的 Assets Store 中搜索 Skybox ，下载资源，主要为六张图片。之后新建Material，Inspector—-&gt;Shader—-&gt;Skybox，拖入六张图片，即制作好了一个材料。 下一步为摄像机添加组件，Add Component—-&gt;Rendering—-&gt;Skybox，拖入上一部创建好的图片就OK啦。 摄像机 ： 打开Camera的Inspector视图，可看到Projection属性： 有两个选项：Perspective(透视视图) ，和 Orthographic(正交视图) 。正交视图与摄像机距离无关，实现2D投影效果，透视试图则是属于3D效果。 设置两个摄像机，一个为主，采用透视视图，另一为辅，为正交视图。 需注意的重点是，若要使辅助摄像机位于视图左下角，则需调整 Depth 和视图大小，确保辅助摄像机的深度大于主摄像机。 _地形_ ： Create—-&gt;3D Object—-&gt;Terrain，即可创建地形对象： 可用来改造地形，种树，花草等等，不过若要种树，则需从 Assets Store 中下载相关资源，从中找到树木的预制，即可应用于地形中。 _海水_ ： Assets—-&gt;Import Package—-&gt;Environment，即可从该资源包中找到 Water 预制，拖入场景中，调整位置即可实现海水效果。 牧师与魔鬼详见代码","categories":[{"name":"3D Game","slug":"3D-Game","permalink":"http://chaunceyzhangx.github.io/categories/3D-Game/"}],"tags":[{"name":"博客","slug":"博客","permalink":"http://chaunceyzhangx.github.io/tags/博客/"}]},{"title":"Unity 3D 基础概念","slug":"Unity 3D之Homework1","date":"2018-03-27T11:54:00.000Z","updated":"2018-04-11T03:59:00.127Z","comments":true,"path":"2018/03/27/Unity 3D之Homework1/","link":"","permalink":"http://chaunceyzhangx.github.io/2018/03/27/Unity 3D之Homework1/","excerpt":"基础概念 GameObjects: 游戏对象，即游戏中的最基本单位，游戏中的每一个对象都是游戏对象。它相当于一个容器，本身并无太多属性，需添加各种组件，资源后才能达到设计者的所希望的游戏行为目的。","text":"基础概念 GameObjects: 游戏对象，即游戏中的最基本单位，游戏中的每一个对象都是游戏对象。它相当于一个容器，本身并无太多属性，需添加各种组件，资源后才能达到设计者的所希望的游戏行为目的。 Assets: 指可应用于Unity上的各种资源，为游戏添加各种属性，从而实现目标效果；同时，一个Unity Project的Assets文件夹指存储于本地计算机中的各种图片，预制，script等文件的总和。一个Assets中可以包含多个GameObject，GameObject从逻辑上讲存储于Assets文件夹中。 游戏结构目录：Assets Scene 保存游戏场景 Game 保存美术资源 Materials 保存材质球，用于调整颜色等 Prefabs 保存预制，即游戏对象的模板，方便克隆 Model _模型_ Animations 保存动画文件 Audio 音频文件 Textures 贴图文件 UI UI文件 Scripts 脚本文件 Plugins _插件_ Editor 保存编辑器类文件 MonoBehaviour 基本行为触发条件：代码如下： 1234567891011121314151617181920212223242526272829303132// Use this for initializationvoid Start () &#123; Debug.Log(&quot;init Start&quot;);&#125;// Update is called once per framevoid Update () &#123; Debug.Log(&quot;init Update&quot;);&#125;void Awake()&#123; Debug.Log(&quot;init Awake&quot;);&#125;void FixedUpdate()&#123; Debug.Log(&quot;init FixedUpdate&quot;);&#125;void LateUpdate()&#123; Debug.Log(&quot;init LateUpdate&quot;);&#125;void OnGUI()&#123; Debug.Log(&quot;init OnGUI&quot;);&#125;void OnDisable()&#123; Debug.Log(&quot;init OnDisable&quot;);&#125;void OnEnable()&#123; Debug.Log(&quot;init OnEnable&quot;);&#125; Start: Per frame: End: 结论: Awake(): 当脚本实例被载入时调用； Start(): 在Update()前被调用一次； Update(): 行为启用时，每一帧被调用一次； FixedUpdate(): 行为启用时，每一时间片被调用； LateUpdate(): 行为启用时，Update()之后被调用； OnGUI(): 每帧调用多次，响应GUI事件； OnEnable(): 当对象变为启用并激活时，调用该函数； OnDisable(): 当对象变为禁用或不活动时，调用该函数。 简单介绍GameObject, Transform 和 Component，并画出三者的UML图。 GameObject: Unity 场景中所有实体的基类。 Transform: 一个对象的位置，旋转和大小。 Component: 所有附加到游戏对象的属性的基类。 UML 简单代码 查找对象新建项目，其中有 Sphere 游戏对象，代码如下： 1234567891011121314151617void Start() &#123; Debug.Log(&quot;init start&quot;); &#125; void FixedUpdate() &#123; var x = GameObject.Find(&quot;Sphere&quot;); if (x.name != null) &#123; Debug.Log(&quot;find the gameobject&quot;); &#125; else &#123; Debug.Log(&quot;Not found&quot;); &#125; &#125; 添加子对象代码如下： 1234567void Start()&#123; GameObject sph = GameObject.Find(&quot;Sphere&quot;); GameObject child = GameObject.CreatePrimitive(PrimitiveType.Cube); child.transform.parent = sph.transform; Debug.Log(&quot;Success&quot;);&#125; 遍历对象树代码如下： 123456789GameObject obj = GameObject.Find(&quot;Sphere&quot;);print(&quot;父对象名称为:&quot; + obj.name + &quot; 有&quot; + obj.transform.childCount + &quot;个子对象&quot;);int i = 0;while (i &lt; obj.transform.childCount)&#123; Transform child = obj.transform.GetChild(i); print(&quot;这是第: &quot; + i + &quot; 个子对象, 名称为: &quot; + child.name); i++;&#125; 清除所有子对象代码如下： 1234567891011GameObject obj = GameObject.Find(&quot;Sphere&quot;);print(&quot;父对象名称为:&quot; + obj.name + &quot; 有&quot; + obj.transform.childCount + &quot;个子对象&quot;);int i = 0;while (i &lt; obj.transform.childCount)&#123; Transform child = obj.transform.GetChild(i); print(&quot;这是第: &quot; + i+1 + &quot; 个子对象, 名称为: &quot; + child.name); GameObject pchild = GameObject.Find(child.name); GameObject.Destroy(pchild); i++;&#125; 预设与对象克隆 Prefabs: 预制可以存储一个带有组件和属性的 GameObject 作为模板，当想创建新的实例时，可以直接拖动模板进行创建。对预制做的修改可以应用到由该模板生成的所有实例中，也可以单独编辑每一个实例。 总的来说，预设和对象克隆都能生成新的对象实例，但相比较而言，由 clone 生成的实例，编辑原对象时，就不能应用到所有实例中。 预制 table : 12345public GameObject prefab;void Start()&#123; Instantiate(prefab, new Vector3(2.0F, 0, 0), Quaternion.identity);&#125; 组合模式 组合模式: 定义：组合模式，将对象组合成树形结构以表示“部分-整体”的层次结构。组合模式使得用户对组合对象和单个对象的使用具有一致性。 包含三个部分：抽象构件，叶子构件和容器构件。 目的即是使得对根节点的调用方法对叶子节点同样适用，使得工作效率更高。 代码：​ 有三种发送消息的函数，其中BroadcastMessage()由父类发送给子类，括号里面：第一个参数为回应的函数，第二个参数为传递给回应函数的参数。 1234567void Start () &#123; gameObject.BroadcastMessage(&quot;MySon&quot;,&quot;I am your father&quot;);&#125;void MySon(string ss)&#123; Debug.Log(&quot;I am your son&quot;);&#125;","categories":[{"name":"3D Game","slug":"3D-Game","permalink":"http://chaunceyzhangx.github.io/categories/3D-Game/"}],"tags":[{"name":"博客","slug":"博客","permalink":"http://chaunceyzhangx.github.io/tags/博客/"}]}]}